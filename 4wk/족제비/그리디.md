### 그리디(Greedy) 알고리즘이란?

최적화 알고리즘 중 하나. 매 순간 가장 최적의 선택을 하여 답을 찾는 방식.

최종 답이 최적해가 아닐 수 있으므로 답이 최적해인지 검증하는 단계가 필요하다.

근사적인 최적해를 찾을 수 있어 근사 알고리즘으로도 사용할 수 있다.

- **최적화 알고리즘** : 최적해를 찾는 알고리즘
- **최적해** : 주어진 조건을 가장 잘 달성하거나 목적 함수값을 최대 또는 최소로 하는 해
    
    ex) 최소 비용 경로 문제에서 최적해 : 가장 적은 비용을 갖는 경로
    
    최대 수익 : 가장 큰 수익을 갖는 결정 혹은 가장 낮은 비용을 갖는 결정
    
- **근사 알고리즘** : 최적화 알고리즘에서 근사값을 찾는 것. 최적값을 찾지는 못하지만, 비교적 빠른 시간에 어느 정도 보장된 근사값을 찾을 수 있다는 장점.

### 특징

아래 두 가지 조건이 성립하면 그리디 알고리즘을 통해 근사적인 최적해를 구할 수 있다.

**탐욕 선택 조건(Greedy Choice Property)**

- 현재 선택이 이후의 선택에 영향을 주지 않음
- 각 선택은 단순히 현재 상황에서 가장 최적인 값을 고려
- 이후의 선택이나 전체 문제의 해결 방법의 영향을 고려하지 않음
- ex) 최단 경로를 찾는 문제에서, A→B 를 선택한 간선의 가중치가 B→E 로 향하는 간선을 선택하는 데 영향을 주지 않음.

**최적 부분 구조 조건(Optimal Substructure)**

- 큰 문제의 최적해가 작은 부분 문제의 최적해로부터 구성될 수 있는 구조
- 즉, 문제를 작은 부분 문제로 나눌 수 있으며 각 부분 문제의 최적해를 결합해 전체 문제의 최적해를 찾을 수 있는 구조
- ex) 피보나치 수열, 최단 경로

### 단계

1. **선택 단계 (Selection Step)**
    
    현재 단계에서 가장 좋아보이는 선택을 한다.
    
2. **적절성 확인 (Feasibility Check)**
    
    선택한 해가 적절한지 검사하고, 조건을 만족하지 않으면 선택을 무효화한다.
    
3. **해답 검사 (Solution Check)**
    
    모든 선택이 완료되면 해답을 검증한다. 항상 최적해를 보장하지는 않으므로 근사값으로 받아들일 수 있다.
    

## 그리디 알고리즘 예시

### 거스름돈 문제

손님에게 거슬러줘야할 돈이 N원일 때, 동전의 개수를 가장 적게 거슬러 주는 방법을 찾아라

> 주어진 동전 : 500원, 100원, 50원, 10원
> 
> 
> ex) 1460원을 받았을 때 ⇒ 500원 2개, 100원 4개, 50원 1개, 10원 1개 ⇒ 총 8개
> 

매 순간 가장 좋아보이는 선택 ⇒ 가장 큰 화폐 단위를 선택

```java
public static void main(String[] args) {
	int receiveMoney = 1460;
	int coins[] = {500, 100, 50, 10};
	
	int answer[] = new int[];

	int currentMoney = receiveMoney;
	for (int i=0; i<coins.length; i++) {
		if(currentMoney <= 0) break;
		currentMoney %= currentMoney/coins[i];  //가장 큰 화폐 단위 선택
		answer[i] = currentMoney/coins[i];
	}
}
```
