
백트래킹이란 해를 찾는 도중에 막히면 더 이상 깊이 들어가지 않고, 이전 단계로 되돌아가서 해를 찾아나가는 기법을 말한다. 
최적화 문제와 결정 문제를 푸는 방법이다. 단순 다중 for문 보다는 빠르게 해결되는 경우가 많다.
> 어떤 노드의 유망성, 즉 해가 될 만한지 판단한 후 유망하지 않다고 결정되면 그 노드의 이전(부모)로 돌아가(Backtracking) 다음 자식 노드로 간다.
해가 될 가능성이 있으면 유망하다(promising)고 하며, 유망하지 않은 노드에 가지 않는 것을 가지치기(pruning) 한다고 하는 것.

- 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 탐색
- 어떤 노드를 방문했을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않음
- 해답의 가능성이 있으면 유망함
- 가지치기 사용가능 (유망하지 않은 노드가 포함되는 경로는 고려하지 않는 기법)
- 기본적으로 재귀의 성격을 띄는 형태


DFS vs. 백트래킹

백트래킹
어떤 노드에서 출발하는 경로가 그 해결책으로 이어질 것 같지 않으면 더 이상 경로를 탐색하지 않음으로써 시도 횟수 감소.
불필요한 경로의 조기 차단
N! 가지의 경우의 수를 가진 문제에 대해 백트레킹에 가하면 일반적으로 경우의 수가 줄어들지만 최악의 경우는 처리 불가능
**모든 후보를 검사하지 않음**


DFS
모든 경로를 추적
N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 이용하면 처리 불가능
**모든 후보를 검사**



코드의 형태
def 재귀함수(n):
	if 정답이면 :
		출력 or 저장
	else : 정답이 아니면 :
		for 모든 자식 노드에 대해서:
			if 정답에 유망하다면(답의 가능성이 있으면) :
				자식노드로이동
				재귀함수(n+1)
				부모노드로 이동


백트래킹의 장점은 해결책을 찾을 때까지 모든 가능성을 탐색하는 것이 아니라, 해결책에 대한 후보군을 구성하여 불필요한 탐색을 줄일 수 있다는 것. 따라서, 백트래킹 알고리즘은 대규모 문제를 효과적으로 해결할 수 있음.

백트래킹은 대표적으로 스도쿠, N-Queen, 암호해독 등의 문제에서 활용.
