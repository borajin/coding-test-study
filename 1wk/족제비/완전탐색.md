## 완전 탐색(Exhaustive Search) 이란?

모든 경우의 수를 탐색하는 방법.

입력의 크기만큼 공간/시간 복잡도를 많이 소모하므로 입력의 크기나 경우의 수가 제한적인 경우에 유용함.

완전탐색을 적용하기 전 다른 방법(DP, 백트래킹 등)은 없는지 먼저 판단 필요.

## 시간복잡도

입력의 크기에 따라 지수적으로 증가

따라서 입력의 크기가 크거나 경우의 수가 많은 경우 비효율적일 수 있음.

## 완전 탐색 알고리즘의 예시

### Brute-Force (brute=무식한, brute-force=무식한해결방법)

- 단순히 반복문을 통해 모든 경우의 수를 탐색함
- 시간 복잡도 : `O(nm)` - n개의 입력에 대해, m번 반복문을 중첩하는 만큼 곱하기

### 재귀

- 재귀 함수를 활용
- 자연스럽게 재귀적인 구조를 가지는 문제에서 주로 활용 (트리 구조, 그래프 탐색, 분할 정복, 점화식을 사용하는 문제 등)
- 작은 문제로 나눠 결과를 기억해 큰 문제를 해결할 때 사용하는 DP에서의 재귀함수와 달리, 단순히 해결방법을 전부 시도하는 구조.
- 탈출 조건을 제대로 명시하지 않으면 무한재귀에 빠져 스택 오버플로우가 발생할 수 있음.
- 시간 복잡도 : 문제의 성격에 따라 다름 (상수시간 `O(k)`, 선형시간 `O(n)` , 지수시간 `O(n^2)` 등)

### 순열

- 순열 : 순서가 부여된 임의의 집합을 다른 순서대로 뒤섞는 연산.  n개중에서 r개를 택해 순서대로 배열한 조합의 경우의 수를 계산하는 연산.

$$
nPr (ex: 5P3 = 5*4*3)
$$

- 입력의 순서 조합을 변경해가며 가능한 모든 순서 조합을 탐색
- 입력을 특정 순서 조합으로 나열하는 것이 중요한 경우, 수학적 문제 등에서 활용 (ex: 암호해독, 단어생성 등)
- 순열을 구현하는 방법에는 여러 가지가 있으며, 주로 재귀와 반복문을 사용함
- 순열 라이브러리가 있는 프로그래밍 언어도 있음.
- 시간 복잡도 : `nPr`, 최악의 경우 `O(n!)` - 조합이 만들어지는 만큼. (곱의 법칙)

### BFS/DFS

- BFS, DFS를 활용하여 완전 탐색하는 방법
- 그래프나 트리에서 완전 탐색을 하는 경우 주로 활용
- 별도의 요약본에서 다루기로…
- 시간복잡도 : 인접리스트로 표현하는 경우 `O(V + E)` , 인접행렬로 표현하는 경우 `O(V^2)` *v:노드수, e:간선수*

**너비 우선 탐색(BFS)**

- 그래프나 트리를 탐색할 때 너비를 우선으로 탐색하는 방법
- 루트 노드에서 시작해 인접 노드를 먼저 전부 탐색한 후, 인접 노드의 인접 노드를 탐색하는 과정을 반복.
- 주로 큐를 활용
- 가장 가까운 인접 노드를 탐색하는 것이 유용한 경우에 활용 : 최단 경로 찾기, 미로 찾기, 네트워크 연결성 검사 등

**깊이 우선 탐색(DFS)**

- 그래프나 트리를 탐색할 때 깊이를 우선으로 탐색하는 방법
- 루트 노드에서 시작해 한 노드의 자식 노드를 끝까지 탐색한 뒤, 그 다음 인접 노드로 이동해 재귀적으로 탐색
- 주로 스택 또는 재귀를 활용
- 한 경로를 따라 최대한 깊이 탐색해야 하는 경우에 활용 : 그래프의 순회, 연결 요소 찾기, 위상 정렬 등에 활용됨

![997C3C3E5BD01AF41D.gif](https://prod-files-secure.s3.us-west-2.amazonaws.com/888323b4-351a-4862-92ad-b4b083d18914/ff6afe23-1184-4eaa-9b9b-c811f7d35d70/997C3C3E5BD01AF41D.gif)

### Bitmask

- 비트 연산을 활용
