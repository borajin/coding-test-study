### DP(동적계획법)

- 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법
- dynamic에는 특별한 뜻은 없다.
- 큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용해서 기억하며 풀기라고 부르기도 한다.
- 결과 저장용 리스트를 DP테이블이라고 한다.

### 사용조건

1. 최적 부분 구조(Optimal Substrcture)
    1. 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 경우
2. 중복되는 부분 문제(Overlapping Subproblem)
    1. 동일한 작은 문제를 반복적으로 해결해야하는 경우

### 사용이유

- 일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복되어 비효율 적인 계산이 될 수 있기 때문이다.
- 피보나치 수열
    - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55…
    - 재귀함수로 피보나치 수열을 구하면? f(n) = f(n-1) + f(n-2)
    - 재귀함수로 구할 때에 아래 그림과 같이 이미 구현했던 값임에도 불구하고 반복해서 재귀호출이 발생한다.
    - 시간복잡도 : $O(2^n)$
    - 이미 계산했던 값을 재사용 하게 된다면 효율적으로 문제를 해결할 수 있다.

### 구현방법

1. 동적 계획 법으로 풀 수 있는지 확인한다.
    1. 동적 계획법의 사용 조건에 충족하는 문제인지 판단한다.
    2. 보통 특정 데이터 내 최대화 . 최소화 계산을 하거나 특정 조건 내 데이터를 세야한다는 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.
2. 점화식 세우기
    1. 논리적으로 전체 문제를 나누고, 전체 문제와 부분 문제 간의 인과 관계를 파악하고 이것을 식으로 만들어 내야한다.
    2. 점화식을 통해 반복/재귀를 통해 문제가 자동으로 해결될 수 있도록 구현할 수 있다.
    3. 피보나치 수열: f(n) = f(n-1) + f(n-2)
3. 메모이제이션(Memoization)
    1. 모든 작은 문제들은 한 번만 계산해 DP테이블에 저장하며 추후 재사용할 때 이 DP테이블을 이용한다.
    2. 결과 값을 저장할 때 보통 배열을 쓰며 변수의 개수에 따라 배원의 차원이 다양해진다.
    3. 값을 기록해 놓는다는 점에서 캐싱(Cashing)이라고도 함
4. 기저 상태파악하기
    1. 가장 작은 문제의 상태를 알아야 한다.
    2. 피보나치 수열의 경우 f(0)=0, f(1)=1
    3. 기저 문제에 대해 파악한 후 미리 배열 등에 저장해두면된다.
    4. 문제에 따라 파악이 어려울 수 있다.
5. 구현하기
    - 톱-다운(top-down) 방식
        - 위에서부터 문제를 파악해 내려오는 방식
        - 주로 **재귀함수** 형태로 구현
        - 코드의 가독성이 좋고, 이해하기 편함
        - 이미 계산이 완료된 경우 단순히 메모리에 저장되어 있던 내용을 꺼내서 활용하면 됨
            
            ⇒ 가장 최근의 상태 값을 메모해 두었다고 해서 memoization이라고도 부름
            
    - 바텀-업(bottom-up) 방식
        - 가장 작은 부분 문제부터 해결하면서 점점 큰 문제로 확장해나가는 방식
        - 주로 **반복문**으로 구현
        - 처음부터 하나 하나씩 채우는 과정을 table-filling이라하고, 이 테이블에 저장된 값에 직접 접근하여 재활용하므로 tabulation이라고 한다.
        - 결과를 기억하고 재활용한다는 측면에서 메모리제이션과 크게 다르지 않다.

### Top-down VS Bottom-up

- 탑다운의 경우 재귀를 이용해 필요없는 계산은 하지 않아도 되지만, 너무 많은 재귀 호출이 일어나면 스택이 많이 쌓여, StackOverFlow가 발생할 수 있다.
- 바텀업의 경우 테이블을 처음부터 채워나가야하기 때문에 필요없는 값을 계산해야 하는 경우가 발생할 수 있다.
